"""Database-backed user auth and per-user saved BAC sessions."""

from __future__ import annotations

import json
import re
import secrets
import sqlite3
from datetime import datetime, timedelta, timezone
from contextlib import contextmanager
from typing import Any

from werkzeug.security import check_password_hash, generate_password_hash

try:
    import psycopg
    from psycopg.rows import dict_row, tuple_row
except Exception:  # pragma: no cover
    psycopg = None
    dict_row = None
    tuple_row = None


def _is_postgres_db(db_path: str) -> bool:
    return db_path.startswith("postgres://") or db_path.startswith("postgresql://")


def _adapt_sql_for_postgres(query: str) -> str:
    q = query
    q = q.replace("COLLATE NOCASE", "")
    q = q.replace("datetime('now', '-30 minutes')", "CURRENT_TIMESTAMP - INTERVAL '30 minutes'")
    q = q.replace("datetime('now')", "CURRENT_TIMESTAMP")
    q = q.replace("ORDER BY rowid DESC", "ORDER BY id DESC")
    if "INSERT OR IGNORE INTO" in q:
        q = q.replace("INSERT OR IGNORE INTO", "INSERT INTO")
        if "ON CONFLICT" not in q:
            q = q.rstrip().rstrip(";") + " ON CONFLICT DO NOTHING"
    # sqlite qmark -> postgres pyformat
    q = q.replace("?", "%s")
    return q


class _ConnWrapper:
    def __init__(self, db_path: str):
        self.db_path = db_path
        self.is_postgres = _is_postgres_db(db_path)
        self._row_factory = None
        if self.is_postgres:
            if psycopg is None:
                raise RuntimeError("psycopg is required for Postgres DATABASE_URL support")
            self._conn = psycopg.connect(db_path)
        else:
            self._conn = sqlite3.connect(db_path)

    @property
    def row_factory(self):
        if self.is_postgres:
            return self._row_factory
        return self._conn.row_factory

    @row_factory.setter
    def row_factory(self, value):
        if self.is_postgres:
            self._row_factory = value
        else:
            self._conn.row_factory = value

    def execute(self, query: str, params: tuple[Any, ...] | list[Any] = ()):
        if self.is_postgres:
            rf = dict_row if self._row_factory is sqlite3.Row else tuple_row
            cur = self._conn.cursor(row_factory=rf)
            cur.execute(_adapt_sql_for_postgres(query), params)
            return cur
        return self._conn.execute(query, params)

    def commit(self) -> None:
        self._conn.commit()

    def __getattr__(self, item: str):
        return getattr(self._conn, item)

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc, tb):
        if exc_type:
            try:
                self._conn.rollback()
            except Exception:
                pass
        self._conn.close()
        return False


@contextmanager
def _connect(db_path: str):
    with _ConnWrapper(db_path) as conn:
        yield conn


def _slugify_username(value: str) -> str:
    base = re.sub(r"[^a-z0-9_]", "", value.strip().lower().replace(" ", "_"))
    return base[:24]


def _unique_username(conn: sqlite3.Connection, preferred: str) -> str:
    base = _slugify_username(preferred) or f"user{secrets.randbelow(10_000)}"
    candidate = base
    suffix = 2
    while True:
        exists = conn.execute("SELECT 1 FROM users WHERE username = ?", (candidate,)).fetchone()
        if exists is None:
            return candidate
        candidate = f"{base[: max(1, 24 - len(str(suffix)))]}{suffix}"
        suffix += 1


def _unique_invite_code(conn: sqlite3.Connection) -> str:
    while True:
        code = secrets.token_urlsafe(8)[:10].upper()
        exists = conn.execute("SELECT 1 FROM users WHERE invite_code = ?", (code,)).fetchone()
        if exists is None:
            return code


def init_db(db_path: str) -> None:
    if _is_postgres_db(db_path):
        with _connect(db_path) as conn:
            conn.execute(
                """
                CREATE TABLE IF NOT EXISTS users (
                    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    email TEXT NOT NULL UNIQUE,
                    password_hash TEXT NOT NULL,
                    display_name TEXT NOT NULL,
                    email_verified INTEGER NOT NULL DEFAULT 0,
                    is_male INTEGER,
                    default_weight_lb DOUBLE PRECISION,
                    username TEXT UNIQUE,
                    invite_code TEXT UNIQUE,
                    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
                )
                """
            )
            conn.execute(
                """
                CREATE TABLE IF NOT EXISTS saved_sessions (
                    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    user_id BIGINT NOT NULL REFERENCES users(id),
                    name TEXT NOT NULL,
                    payload_json TEXT NOT NULL,
                    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
                    is_auto INTEGER NOT NULL DEFAULT 0,
                    is_active INTEGER NOT NULL DEFAULT 0,
                    started_at TIMESTAMPTZ,
                    last_event_at TIMESTAMPTZ,
                    updated_at TIMESTAMPTZ,
                    ended_at TIMESTAMPTZ
                )
                """
            )
            conn.execute("CREATE INDEX IF NOT EXISTS idx_saved_sessions_user_active ON saved_sessions(user_id, is_active)")
            conn.execute("CREATE INDEX IF NOT EXISTS idx_saved_sessions_user_id ON saved_sessions(user_id)")
            conn.execute(
                """
                CREATE TABLE IF NOT EXISTS user_favorites (
                    user_id BIGINT NOT NULL REFERENCES users(id),
                    catalog_id TEXT NOT NULL,
                    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
                    PRIMARY KEY (user_id, catalog_id)
                )
                """
            )
            conn.execute(
                """
                CREATE TABLE IF NOT EXISTS user_social_settings (
                    user_id BIGINT PRIMARY KEY REFERENCES users(id),
                    share_with_friends INTEGER NOT NULL DEFAULT 0,
                    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
                )
                """
            )
            conn.execute(
                """
                CREATE TABLE IF NOT EXISTS friend_requests (
                    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    from_user_id BIGINT NOT NULL REFERENCES users(id),
                    to_user_id BIGINT NOT NULL REFERENCES users(id),
                    status TEXT NOT NULL DEFAULT 'pending',
                    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
                    responded_at TIMESTAMPTZ,
                    UNIQUE(from_user_id, to_user_id)
                )
                """
            )
            conn.execute(
                """
                CREATE TABLE IF NOT EXISTS friendships (
                    user_id BIGINT NOT NULL REFERENCES users(id),
                    friend_user_id BIGINT NOT NULL REFERENCES users(id),
                    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
                    PRIMARY KEY (user_id, friend_user_id)
                )
                """
            )
            conn.execute(
                """
                CREATE TABLE IF NOT EXISTS user_presence (
                    user_id BIGINT PRIMARY KEY REFERENCES users(id),
                    bac_now DOUBLE PRECISION NOT NULL DEFAULT 0.0,
                    drink_count INTEGER NOT NULL DEFAULT 0,
                    location_note TEXT,
                    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
                )
                """
            )
            conn.execute(
                """
                CREATE TABLE IF NOT EXISTS social_groups (
                    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    name TEXT NOT NULL,
                    invite_code TEXT NOT NULL UNIQUE,
                    owner_user_id BIGINT NOT NULL REFERENCES users(id),
                    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
                )
                """
            )
            conn.execute(
                """
                CREATE TABLE IF NOT EXISTS group_members (
                    group_id BIGINT NOT NULL REFERENCES social_groups(id),
                    user_id BIGINT NOT NULL REFERENCES users(id),
                    role TEXT NOT NULL DEFAULT 'member',
                    share_enabled INTEGER NOT NULL DEFAULT 0,
                    joined_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
                    PRIMARY KEY (group_id, user_id)
                )
                """
            )
            conn.execute(
                """
                CREATE TABLE IF NOT EXISTS group_buddy_pairs (
                    group_id BIGINT NOT NULL REFERENCES social_groups(id),
                    user_id BIGINT NOT NULL REFERENCES users(id),
                    buddy_user_id BIGINT NOT NULL REFERENCES users(id),
                    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
                    PRIMARY KEY (group_id, user_id)
                )
                """
            )
            conn.execute(
                """
                CREATE TABLE IF NOT EXISTS group_alerts (
                    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    group_id BIGINT NOT NULL REFERENCES social_groups(id),
                    from_user_id BIGINT REFERENCES users(id),
                    target_user_id BIGINT REFERENCES users(id),
                    alert_type TEXT NOT NULL,
                    message TEXT NOT NULL,
                    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
                )
                """
            )
            conn.execute(
                """
                CREATE TABLE IF NOT EXISTS guardian_links (
                    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    group_id BIGINT NOT NULL REFERENCES social_groups(id),
                    label TEXT NOT NULL,
                    token TEXT NOT NULL UNIQUE,
                    receive_alerts INTEGER NOT NULL DEFAULT 1,
                    is_active INTEGER NOT NULL DEFAULT 1,
                    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
                )
                """
            )
            conn.execute("ALTER TABLE users ADD COLUMN IF NOT EXISTS email_verified INTEGER NOT NULL DEFAULT 0")
            conn.execute(
                """
                CREATE TABLE IF NOT EXISTS emergency_contacts (
                    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    user_id BIGINT NOT NULL REFERENCES users(id),
                    name TEXT NOT NULL,
                    phone TEXT NOT NULL,
                    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
                )
                """
            )
            conn.execute(
                """
                CREATE TABLE IF NOT EXISTS password_resets (
                    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    user_id BIGINT NOT NULL REFERENCES users(id),
                    token TEXT NOT NULL UNIQUE,
                    expires_at TIMESTAMPTZ NOT NULL,
                    used_at TIMESTAMPTZ
                )
                """
            )
            conn.execute(
                """
                CREATE TABLE IF NOT EXISTS email_verifications (
                    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    user_id BIGINT NOT NULL REFERENCES users(id),
                    token TEXT NOT NULL UNIQUE,
                    expires_at TIMESTAMPTZ NOT NULL,
                    used_at TIMESTAMPTZ
                )
                """
            )
            # Backfill username/invite_code for older rows.
            conn.row_factory = sqlite3.Row
            existing = conn.execute(
                "SELECT id, display_name, email, username, invite_code FROM users WHERE username IS NULL OR invite_code IS NULL"
            ).fetchall()
            for row in existing:
                user_id = row["id"]
                display_name = row["display_name"]
                email = row["email"]
                username = row["username"]
                invite_code = row["invite_code"]
                if not username:
                    fallback = (display_name or str(email).split("@")[0] or f"user{user_id}")
                    username = _unique_username(conn, str(fallback))
                if not invite_code:
                    invite_code = _unique_invite_code(conn)
                conn.execute("UPDATE users SET username = ?, invite_code = ? WHERE id = ?", (username, invite_code, user_id))
            conn.commit()
        return

    with _connect(db_path) as conn:
        conn.execute("PRAGMA journal_mode=WAL")
        conn.execute(
            """
            CREATE TABLE IF NOT EXISTS users (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                email TEXT NOT NULL UNIQUE,
                password_hash TEXT NOT NULL,
                display_name TEXT NOT NULL,
                email_verified INTEGER NOT NULL DEFAULT 0,
                is_male INTEGER,
                default_weight_lb REAL,
                created_at TEXT NOT NULL DEFAULT (datetime('now'))
            )
            """
        )
        # Lightweight migration for older DBs created before profile columns existed.
        cols = {row[1] for row in conn.execute("PRAGMA table_info(users)").fetchall()}
        if "is_male" not in cols:
            conn.execute("ALTER TABLE users ADD COLUMN is_male INTEGER")
        if "default_weight_lb" not in cols:
            conn.execute("ALTER TABLE users ADD COLUMN default_weight_lb REAL")
        if "email_verified" not in cols:
            conn.execute("ALTER TABLE users ADD COLUMN email_verified INTEGER NOT NULL DEFAULT 0")
        if "username" not in cols:
            conn.execute("ALTER TABLE users ADD COLUMN username TEXT")
        if "invite_code" not in cols:
            conn.execute("ALTER TABLE users ADD COLUMN invite_code TEXT")
        conn.execute("CREATE UNIQUE INDEX IF NOT EXISTS idx_users_username_unique ON users(username)")
        conn.execute("CREATE UNIQUE INDEX IF NOT EXISTS idx_users_invite_code_unique ON users(invite_code)")
        # Backfill username/invite_code for existing rows if missing.
        existing = conn.execute(
            "SELECT id, display_name, email, username, invite_code FROM users WHERE username IS NULL OR invite_code IS NULL"
        ).fetchall()
        for row in existing:
            user_id, display_name, email, username, invite_code = row
            if not username:
                fallback = (display_name or email.split("@")[0] or f"user{user_id}")
                username = _unique_username(conn, str(fallback))
            if not invite_code:
                invite_code = _unique_invite_code(conn)
            conn.execute("UPDATE users SET username = ?, invite_code = ? WHERE id = ?", (username, invite_code, user_id))
        conn.execute(
            """
            CREATE TABLE IF NOT EXISTS saved_sessions (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                name TEXT NOT NULL,
                payload_json TEXT NOT NULL,
                created_at TEXT NOT NULL DEFAULT (datetime('now')),
                FOREIGN KEY(user_id) REFERENCES users(id)
            )
            """
        )
        saved_cols = {row[1] for row in conn.execute("PRAGMA table_info(saved_sessions)").fetchall()}
        if "is_auto" not in saved_cols:
            conn.execute("ALTER TABLE saved_sessions ADD COLUMN is_auto INTEGER NOT NULL DEFAULT 0")
        if "is_active" not in saved_cols:
            conn.execute("ALTER TABLE saved_sessions ADD COLUMN is_active INTEGER NOT NULL DEFAULT 0")
        if "started_at" not in saved_cols:
            conn.execute("ALTER TABLE saved_sessions ADD COLUMN started_at TEXT")
        if "last_event_at" not in saved_cols:
            conn.execute("ALTER TABLE saved_sessions ADD COLUMN last_event_at TEXT")
        if "updated_at" not in saved_cols:
            conn.execute("ALTER TABLE saved_sessions ADD COLUMN updated_at TEXT")
        if "ended_at" not in saved_cols:
            conn.execute("ALTER TABLE saved_sessions ADD COLUMN ended_at TEXT")
        conn.execute("CREATE INDEX IF NOT EXISTS idx_saved_sessions_user_active ON saved_sessions(user_id, is_active)")
        conn.execute("CREATE INDEX IF NOT EXISTS idx_saved_sessions_user_id ON saved_sessions(user_id)")
        conn.execute(
            """
            CREATE TABLE IF NOT EXISTS user_favorites (
                user_id INTEGER NOT NULL,
                catalog_id TEXT NOT NULL,
                updated_at TEXT NOT NULL DEFAULT (datetime('now')),
                PRIMARY KEY (user_id, catalog_id),
                FOREIGN KEY(user_id) REFERENCES users(id)
            )
            """
        )
        conn.execute(
            """
            CREATE TABLE IF NOT EXISTS user_social_settings (
                user_id INTEGER PRIMARY KEY,
                share_with_friends INTEGER NOT NULL DEFAULT 0,
                updated_at TEXT NOT NULL DEFAULT (datetime('now')),
                FOREIGN KEY(user_id) REFERENCES users(id)
            )
            """
        )
        conn.execute(
            """
            CREATE TABLE IF NOT EXISTS friend_requests (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                from_user_id INTEGER NOT NULL,
                to_user_id INTEGER NOT NULL,
                status TEXT NOT NULL DEFAULT 'pending',
                created_at TEXT NOT NULL DEFAULT (datetime('now')),
                responded_at TEXT,
                UNIQUE(from_user_id, to_user_id),
                FOREIGN KEY(from_user_id) REFERENCES users(id),
                FOREIGN KEY(to_user_id) REFERENCES users(id)
            )
            """
        )
        conn.execute(
            """
            CREATE TABLE IF NOT EXISTS friendships (
                user_id INTEGER NOT NULL,
                friend_user_id INTEGER NOT NULL,
                created_at TEXT NOT NULL DEFAULT (datetime('now')),
                PRIMARY KEY (user_id, friend_user_id),
                FOREIGN KEY(user_id) REFERENCES users(id),
                FOREIGN KEY(friend_user_id) REFERENCES users(id)
            )
            """
        )
        conn.execute(
            """
            CREATE TABLE IF NOT EXISTS user_presence (
                user_id INTEGER PRIMARY KEY,
                bac_now REAL NOT NULL DEFAULT 0.0,
                drink_count INTEGER NOT NULL DEFAULT 0,
                location_note TEXT,
                updated_at TEXT NOT NULL DEFAULT (datetime('now')),
                FOREIGN KEY(user_id) REFERENCES users(id)
            )
            """
        )
        presence_cols = {row[1] for row in conn.execute("PRAGMA table_info(user_presence)").fetchall()}
        if "location_note" not in presence_cols:
            conn.execute("ALTER TABLE user_presence ADD COLUMN location_note TEXT")
        conn.execute(
            """
            CREATE TABLE IF NOT EXISTS social_groups (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                invite_code TEXT NOT NULL UNIQUE,
                owner_user_id INTEGER NOT NULL,
                created_at TEXT NOT NULL DEFAULT (datetime('now')),
                FOREIGN KEY(owner_user_id) REFERENCES users(id)
            )
            """
        )
        conn.execute(
            """
            CREATE TABLE IF NOT EXISTS group_members (
                group_id INTEGER NOT NULL,
                user_id INTEGER NOT NULL,
                role TEXT NOT NULL DEFAULT 'member',
                share_enabled INTEGER NOT NULL DEFAULT 0,
                joined_at TEXT NOT NULL DEFAULT (datetime('now')),
                PRIMARY KEY (group_id, user_id),
                FOREIGN KEY(group_id) REFERENCES social_groups(id),
                FOREIGN KEY(user_id) REFERENCES users(id)
            )
            """
        )
        conn.execute(
            """
            CREATE TABLE IF NOT EXISTS group_buddy_pairs (
                group_id INTEGER NOT NULL,
                user_id INTEGER NOT NULL,
                buddy_user_id INTEGER NOT NULL,
                created_at TEXT NOT NULL DEFAULT (datetime('now')),
                PRIMARY KEY (group_id, user_id),
                FOREIGN KEY(group_id) REFERENCES social_groups(id),
                FOREIGN KEY(user_id) REFERENCES users(id),
                FOREIGN KEY(buddy_user_id) REFERENCES users(id)
            )
            """
        )
        conn.execute(
            """
            CREATE TABLE IF NOT EXISTS group_alerts (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                group_id INTEGER NOT NULL,
                from_user_id INTEGER,
                target_user_id INTEGER,
                alert_type TEXT NOT NULL,
                message TEXT NOT NULL,
                created_at TEXT NOT NULL DEFAULT (datetime('now')),
                FOREIGN KEY(group_id) REFERENCES social_groups(id),
                FOREIGN KEY(from_user_id) REFERENCES users(id),
                FOREIGN KEY(target_user_id) REFERENCES users(id)
            )
            """
        )
        conn.execute(
            """
            CREATE TABLE IF NOT EXISTS guardian_links (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                group_id INTEGER NOT NULL,
                label TEXT NOT NULL,
                token TEXT NOT NULL UNIQUE,
                receive_alerts INTEGER NOT NULL DEFAULT 1,
                is_active INTEGER NOT NULL DEFAULT 1,
                created_at TEXT NOT NULL DEFAULT (datetime('now')),
                FOREIGN KEY(group_id) REFERENCES social_groups(id)
            )
            """
        )
        conn.execute(
            """
            CREATE TABLE IF NOT EXISTS emergency_contacts (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                name TEXT NOT NULL,
                phone TEXT NOT NULL,
                created_at TEXT NOT NULL DEFAULT (datetime('now')),
                FOREIGN KEY(user_id) REFERENCES users(id)
            )
            """
        )
        conn.execute(
            """
            CREATE TABLE IF NOT EXISTS password_resets (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                token TEXT NOT NULL UNIQUE,
                expires_at TEXT NOT NULL,
                used_at TEXT,
                FOREIGN KEY(user_id) REFERENCES users(id)
            )
            """
        )
        conn.execute(
            """
            CREATE TABLE IF NOT EXISTS email_verifications (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                token TEXT NOT NULL UNIQUE,
                expires_at TEXT NOT NULL,
                used_at TEXT,
                FOREIGN KEY(user_id) REFERENCES users(id)
            )
            """
        )
        conn.commit()


def create_user(
    db_path: str,
    *,
    email: str,
    password: str,
    display_name: str,
    username: str | None,
    is_male: bool,
    default_weight_lb: float,
) -> dict[str, Any] | None:
    password_hash = generate_password_hash(password)
    try:
        with _connect(db_path) as conn:
            chosen_username = _unique_username(conn, username or display_name or email.split("@")[0])
            invite_code = _unique_invite_code(conn)
            cur = conn.execute(
                """
                INSERT INTO users (email, password_hash, display_name, username, invite_code, is_male, default_weight_lb)
                VALUES (?, ?, ?, ?, ?, ?, ?)
                """,
                (
                    email.lower().strip(),
                    password_hash,
                    display_name.strip(),
                    chosen_username,
                    invite_code,
                    int(bool(is_male)),
                    float(default_weight_lb),
                ),
            )
            conn.commit()
            user_id = int(cur.lastrowid)
    except Exception as exc:
        # Handle duplicate email/username across SQLite and Postgres backends.
        if "unique" not in str(exc).lower() and "duplicate" not in str(exc).lower():
            raise
        return None

    return {
        "id": user_id,
        "email": email.lower().strip(),
        "display_name": display_name.strip(),
        "username": chosen_username,
        "invite_code": invite_code,
        "email_verified": False,
        "is_male": bool(is_male),
        "default_weight_lb": float(default_weight_lb),
    }


def authenticate_user(db_path: str, *, email: str, password: str) -> dict[str, Any] | None:
    identifier = email.lower().strip()
    with _connect(db_path) as conn:
        conn.row_factory = sqlite3.Row
        row = conn.execute(
            """
            SELECT id, email, display_name, username, invite_code, email_verified, is_male, default_weight_lb, password_hash
            FROM users
            WHERE lower(email) = ? OR lower(username) = ?
            """,
            (identifier, identifier),
        ).fetchone()

    if row is None:
        return None
    try:
        ok = check_password_hash(row["password_hash"], password)
    except ValueError:
        return None
    if not ok:
        return None

    return {
        "id": row["id"],
        "email": row["email"],
        "display_name": row["display_name"],
        "username": row["username"],
        "invite_code": row["invite_code"],
        "email_verified": bool(row["email_verified"]) if row["email_verified"] is not None else False,
        "is_male": bool(row["is_male"]) if row["is_male"] is not None else True,
        "default_weight_lb": row["default_weight_lb"],
    }


def get_user_by_id(db_path: str, user_id: int) -> dict[str, Any] | None:
    with _connect(db_path) as conn:
        conn.row_factory = sqlite3.Row
        row = conn.execute(
            "SELECT id, email, display_name, username, invite_code, email_verified, is_male, default_weight_lb FROM users WHERE id = ?",
            (user_id,),
        ).fetchone()
    if row is None:
        return None
    return {
        "id": row["id"],
        "email": row["email"],
        "display_name": row["display_name"],
        "username": row["username"],
        "invite_code": row["invite_code"],
        "email_verified": bool(row["email_verified"]) if row["email_verified"] is not None else False,
        "is_male": bool(row["is_male"]) if row["is_male"] is not None else True,
        "default_weight_lb": row["default_weight_lb"],
    }


def update_user_profile(
    db_path: str,
    *,
    user_id: int,
    display_name: str,
    username: str,
    is_male: bool,
    default_weight_lb: float,
) -> tuple[bool, str]:
    cleaned_username = _slugify_username(username)
    if not cleaned_username:
        return False, "Username is required"
    try:
        with _connect(db_path) as conn:
            conn.execute(
                """
                UPDATE users
                SET display_name = ?, username = ?, is_male = ?, default_weight_lb = ?
                WHERE id = ?
                """,
                (
                    display_name.strip(),
                    cleaned_username,
                    1 if is_male else 0,
                    float(default_weight_lb),
                    int(user_id),
                ),
            )
            conn.commit()
        return True, "Profile updated."
    except Exception as exc:
        msg = str(exc).lower()
        if "unique" in msg or "duplicate" in msg:
            return False, "Username is already taken."
        raise


def verify_user_password(db_path: str, *, user_id: int, password: str) -> bool:
    with _connect(db_path) as conn:
        conn.row_factory = sqlite3.Row
        row = conn.execute("SELECT password_hash FROM users WHERE id = ?", (int(user_id),)).fetchone()
    if row is None:
        return False
    try:
        return check_password_hash(row["password_hash"], password)
    except ValueError:
        return False


def delete_user_account(db_path: str, *, user_id: int) -> bool:
    with _connect(db_path) as conn:
        conn.row_factory = sqlite3.Row
        owned_groups = conn.execute(
            "SELECT id FROM social_groups WHERE owner_user_id = ?",
            (int(user_id),),
        ).fetchall()
        owned_group_ids = [int(r["id"]) for r in owned_groups]

        for gid in owned_group_ids:
            conn.execute("DELETE FROM guardian_links WHERE group_id = ?", (gid,))
            conn.execute("DELETE FROM group_alerts WHERE group_id = ?", (gid,))
            conn.execute("DELETE FROM group_members WHERE group_id = ?", (gid,))
        conn.execute("DELETE FROM social_groups WHERE owner_user_id = ?", (int(user_id),))

        conn.execute("DELETE FROM group_alerts WHERE from_user_id = ? OR target_user_id = ?", (int(user_id), int(user_id)))
        conn.execute("DELETE FROM group_members WHERE user_id = ?", (int(user_id),))
        conn.execute("DELETE FROM user_presence WHERE user_id = ?", (int(user_id),))
        conn.execute("DELETE FROM user_social_settings WHERE user_id = ?", (int(user_id),))
        conn.execute("DELETE FROM user_favorites WHERE user_id = ?", (int(user_id),))
        conn.execute("DELETE FROM friend_requests WHERE from_user_id = ? OR to_user_id = ?", (int(user_id), int(user_id)))
        conn.execute("DELETE FROM friendships WHERE user_id = ? OR friend_user_id = ?", (int(user_id), int(user_id)))
        conn.execute("DELETE FROM saved_sessions WHERE user_id = ?", (int(user_id),))
        conn.execute("DELETE FROM emergency_contacts WHERE user_id = ?", (int(user_id),))
        conn.execute("DELETE FROM password_resets WHERE user_id = ?", (int(user_id),))
        conn.execute("DELETE FROM email_verifications WHERE user_id = ?", (int(user_id),))
        cur = conn.execute("DELETE FROM users WHERE id = ?", (int(user_id),))
        conn.commit()
        return cur.rowcount > 0


def save_user_session(db_path: str, *, user_id: int, name: str, payload: dict[str, Any]) -> int:
    payload_json = json.dumps(payload, separators=(",", ":"), ensure_ascii=True)
    with _connect(db_path) as conn:
        cur = conn.execute(
            """
            INSERT INTO saved_sessions (
                user_id, name, payload_json, is_auto, is_active, started_at, last_event_at, updated_at, ended_at
            )
            VALUES (?, ?, ?, 0, 0, datetime('now'), datetime('now'), datetime('now'), datetime('now'))
            """,
            (user_id, name.strip(), payload_json),
        )
        conn.commit()
        return int(cur.lastrowid)


def get_active_auto_session(db_path: str, *, user_id: int) -> dict[str, Any] | None:
    with _connect(db_path) as conn:
        conn.row_factory = sqlite3.Row
        row = conn.execute(
            """
            SELECT id, name, started_at, last_event_at, updated_at, payload_json
            FROM saved_sessions
            WHERE user_id = ? AND is_auto = 1 AND is_active = 1
            ORDER BY id DESC
            LIMIT 1
            """,
            (user_id,),
        ).fetchone()
    if row is None:
        return None
    return {
        "id": row["id"],
        "name": row["name"],
        "started_at": row["started_at"],
        "last_event_at": row["last_event_at"],
        "updated_at": row["updated_at"],
        "payload_json": row["payload_json"],
    }


def upsert_auto_session(
    db_path: str,
    *,
    user_id: int,
    name: str,
    payload: dict[str, Any],
    event_time_iso: str,
    touch_last_event: bool,
) -> int:
    payload_json = json.dumps(payload, separators=(",", ":"), ensure_ascii=True)
    with _connect(db_path) as conn:
        conn.row_factory = sqlite3.Row
        active = conn.execute(
            """
            SELECT id
            FROM saved_sessions
            WHERE user_id = ? AND is_auto = 1 AND is_active = 1
            ORDER BY id DESC
            LIMIT 1
            """,
            (user_id,),
        ).fetchone()
        if active is None:
            cur = conn.execute(
                """
                INSERT INTO saved_sessions (
                    user_id, name, payload_json, is_auto, is_active, started_at, last_event_at, updated_at, ended_at
                )
                VALUES (?, ?, ?, 1, 1, ?, ?, ?, NULL)
                """,
                (user_id, name.strip(), payload_json, event_time_iso, event_time_iso, event_time_iso),
            )
            conn.commit()
            return int(cur.lastrowid)

        if touch_last_event:
            conn.execute(
                """
                UPDATE saved_sessions
                SET payload_json = ?, updated_at = ?, last_event_at = ?, name = COALESCE(NULLIF(name, ''), ?)
                WHERE id = ?
                """,
                (payload_json, event_time_iso, event_time_iso, name.strip(), int(active["id"])),
            )
        else:
            conn.execute(
                """
                UPDATE saved_sessions
                SET payload_json = ?, updated_at = ?
                WHERE id = ?
                """,
                (payload_json, event_time_iso, int(active["id"])),
            )
        conn.commit()
        return int(active["id"])


def finalize_active_auto_session(db_path: str, *, user_id: int, ended_at_iso: str | None = None) -> bool:
    ended = ended_at_iso or "datetime('now')"
    with _connect(db_path) as conn:
        if ended_at_iso:
            cur = conn.execute(
                """
                UPDATE saved_sessions
                SET is_active = 0, ended_at = ?, updated_at = ?
                WHERE user_id = ? AND is_auto = 1 AND is_active = 1
                """,
                (ended_at_iso, ended_at_iso, user_id),
            )
        else:
            cur = conn.execute(
                """
                UPDATE saved_sessions
                SET is_active = 0, ended_at = datetime('now'), updated_at = datetime('now')
                WHERE user_id = ? AND is_auto = 1 AND is_active = 1
                """,
                (user_id,),
            )
        conn.commit()
        return cur.rowcount > 0


def list_user_sessions(
    db_path: str,
    *,
    user_id: int,
    limit: int = 200,
    session_date: str | None = None,
    include_active: bool = False,
) -> list[dict[str, Any]]:
    with _connect(db_path) as conn:
        conn.row_factory = sqlite3.Row
        active_sql = "" if include_active else "AND COALESCE(is_active, 0) = 0"
        if session_date:
            rows = conn.execute(
                """
                SELECT id, name, created_at, payload_json, date(created_at) AS session_date,
                       COALESCE(is_auto, 0) AS is_auto, COALESCE(is_active, 0) AS is_active,
                       started_at, last_event_at, ended_at
                FROM saved_sessions
                WHERE user_id = ? AND date(created_at) = ?
                """
                + active_sql
                + """
                ORDER BY rowid DESC
                LIMIT ?
                """,
                (user_id, session_date, max(1, min(limit, 200))),
            ).fetchall()
        else:
            rows = conn.execute(
                """
                SELECT id, name, created_at, payload_json, date(created_at) AS session_date,
                       COALESCE(is_auto, 0) AS is_auto, COALESCE(is_active, 0) AS is_active,
                       started_at, last_event_at, ended_at
                FROM saved_sessions
                WHERE user_id = ?
                """
                + active_sql
                + """
                ORDER BY rowid DESC
                LIMIT ?
                """,
                (user_id, max(1, min(limit, 200))),
            ).fetchall()

    out = []
    for row in rows:
        try:
            payload = json.loads(row["payload_json"] or "{}")
        except json.JSONDecodeError:
            payload = {}
        events = payload.get("events", [])
        out.append(
            {
                "id": row["id"],
                "name": row["name"],
                "created_at": row["created_at"],
                "session_date": row["session_date"],
                "drink_count": len(events) if isinstance(events, list) else 0,
                "is_auto": bool(row["is_auto"]),
                "is_active": bool(row["is_active"]),
                "started_at": row["started_at"],
                "last_event_at": row["last_event_at"],
                "ended_at": row["ended_at"],
            }
        )
    return out


def list_session_dates(db_path: str, *, user_id: int, limit: int = 120) -> list[dict[str, Any]]:
    with _connect(db_path) as conn:
        conn.row_factory = sqlite3.Row
        rows = conn.execute(
            """
            SELECT date(created_at) AS session_date, COUNT(*) AS session_count
            FROM saved_sessions
            WHERE user_id = ?
              AND COALESCE(is_active, 0) = 0
            GROUP BY date(created_at)
            ORDER BY session_date DESC
            LIMIT ?
            """,
            (user_id, max(1, min(limit, 366))),
        ).fetchall()
    return [{"session_date": row["session_date"], "session_count": row["session_count"]} for row in rows]


def get_user_session_payload(db_path: str, *, user_id: int, session_id: int) -> dict[str, Any] | None:
    with _connect(db_path) as conn:
        conn.row_factory = sqlite3.Row
        row = conn.execute(
            """
            SELECT payload_json
            FROM saved_sessions
            WHERE id = ? AND user_id = ?
            """,
            (session_id, user_id),
        ).fetchone()

    if row is None:
        return None
    try:
        return json.loads(row["payload_json"] or "{}")
    except json.JSONDecodeError:
        return None


def list_recent_session_payloads(db_path: str, *, user_id: int, limit: int = 5) -> list[dict[str, Any]]:
    with _connect(db_path) as conn:
        conn.row_factory = sqlite3.Row
        rows = conn.execute(
            """
            SELECT payload_json
            FROM saved_sessions
            WHERE user_id = ? AND COALESCE(is_active, 0) = 0
            ORDER BY id DESC
            LIMIT ?
            """,
            (user_id, max(1, min(limit, 20))),
        ).fetchall()
    out: list[dict[str, Any]] = []
    for row in rows:
        try:
            payload = json.loads(row["payload_json"] or "{}")
        except json.JSONDecodeError:
            payload = {}
        if isinstance(payload, dict):
            out.append(payload)
    return out


def track_favorite_drink(db_path: str, *, user_id: int, catalog_id: str) -> None:
    with _connect(db_path) as conn:
        conn.execute(
            "DELETE FROM user_favorites WHERE user_id = ? AND catalog_id = ?",
            (user_id, catalog_id),
        )
        conn.execute(
            """
            INSERT INTO user_favorites (user_id, catalog_id, updated_at)
            VALUES (?, ?, datetime('now'))
            """,
            (user_id, catalog_id),
        )
        conn.commit()


def list_favorite_drinks(db_path: str, *, user_id: int, limit: int = 6) -> list[str]:
    with _connect(db_path) as conn:
        conn.row_factory = sqlite3.Row
        rows = conn.execute(
            """
            SELECT catalog_id
            FROM user_favorites
            WHERE user_id = ?
            ORDER BY rowid DESC
            LIMIT ?
            """,
            (user_id, max(1, min(limit, 20))),
        ).fetchall()
    return [row["catalog_id"] for row in rows]


def find_user_by_email(db_path: str, *, email: str) -> dict[str, Any] | None:
    with _connect(db_path) as conn:
        conn.row_factory = sqlite3.Row
        row = conn.execute(
            "SELECT id, email, display_name, username, invite_code FROM users WHERE email = ?",
            (email.strip().lower(),),
        ).fetchone()
    if row is None:
        return None
    return {
        "id": row["id"],
        "email": row["email"],
        "display_name": row["display_name"],
        "username": row["username"],
        "invite_code": row["invite_code"],
    }


def find_user_by_username(db_path: str, *, username: str) -> dict[str, Any] | None:
    cleaned = _slugify_username(username)
    if not cleaned:
        return None
    with _connect(db_path) as conn:
        conn.row_factory = sqlite3.Row
        row = conn.execute(
            "SELECT id, email, display_name, username, invite_code FROM users WHERE username = ?",
            (cleaned,),
        ).fetchone()
    if row is None:
        return None
    return {
        "id": row["id"],
        "email": row["email"],
        "display_name": row["display_name"],
        "username": row["username"],
        "invite_code": row["invite_code"],
    }


def find_user_by_invite_code(db_path: str, *, invite_code: str) -> dict[str, Any] | None:
    code = invite_code.strip().upper()
    if not code:
        return None
    with _connect(db_path) as conn:
        conn.row_factory = sqlite3.Row
        row = conn.execute(
            "SELECT id, email, display_name, username, invite_code FROM users WHERE invite_code = ?",
            (code,),
        ).fetchone()
    if row is None:
        return None
    return {
        "id": row["id"],
        "email": row["email"],
        "display_name": row["display_name"],
        "username": row["username"],
        "invite_code": row["invite_code"],
    }


def set_share_with_friends(db_path: str, *, user_id: int, enabled: bool) -> None:
    with _connect(db_path) as conn:
        conn.execute(
            """
            INSERT INTO user_social_settings (user_id, share_with_friends, updated_at)
            VALUES (?, ?, datetime('now'))
            ON CONFLICT(user_id) DO UPDATE SET
              share_with_friends=excluded.share_with_friends,
              updated_at=datetime('now')
            """,
            (user_id, 1 if enabled else 0),
        )
        conn.commit()


def get_share_with_friends(db_path: str, *, user_id: int) -> bool:
    with _connect(db_path) as conn:
        row = conn.execute(
            "SELECT share_with_friends FROM user_social_settings WHERE user_id = ?",
            (user_id,),
        ).fetchone()
    if row is None:
        return False
    return bool(row[0])


def upsert_presence(
    db_path: str,
    *,
    user_id: int,
    bac_now: float,
    drink_count: int,
    location_note: str | None = None,
) -> None:
    with _connect(db_path) as conn:
        conn.execute(
            """
            INSERT INTO user_presence (user_id, bac_now, drink_count, location_note, updated_at)
            VALUES (?, ?, ?, ?, datetime('now'))
            ON CONFLICT(user_id) DO UPDATE SET
              bac_now=excluded.bac_now,
              drink_count=excluded.drink_count,
              location_note=COALESCE(excluded.location_note, user_presence.location_note),
              updated_at=datetime('now')
            """,
            (user_id, float(bac_now), int(drink_count), (location_note or None)),
        )
        conn.commit()


def list_friends(db_path: str, *, user_id: int) -> list[dict[str, Any]]:
    with _connect(db_path) as conn:
        conn.row_factory = sqlite3.Row
        rows = conn.execute(
            """
            SELECT u.id, u.display_name, u.email
            FROM friendships f
            JOIN users u ON u.id = f.friend_user_id
            WHERE f.user_id = ?
            ORDER BY u.display_name COLLATE NOCASE ASC
            """,
            (user_id,),
        ).fetchall()
    return [{"id": r["id"], "display_name": r["display_name"], "email": r["email"]} for r in rows]


def are_friends(db_path: str, *, user_a: int, user_b: int) -> bool:
    with _connect(db_path) as conn:
        row = conn.execute(
            "SELECT 1 FROM friendships WHERE user_id = ? AND friend_user_id = ?",
            (user_a, user_b),
        ).fetchone()
    return row is not None


def send_friend_request(db_path: str, *, from_user_id: int, to_user_id: int) -> tuple[bool, str]:
    if from_user_id == to_user_id:
        return False, "You cannot friend yourself."
    if are_friends(db_path, user_a=from_user_id, user_b=to_user_id):
        return False, "Already friends."
    with _connect(db_path) as conn:
        pending = conn.execute(
            """
            SELECT id FROM friend_requests
            WHERE ((from_user_id = ? AND to_user_id = ?) OR (from_user_id = ? AND to_user_id = ?))
              AND status = 'pending'
            """,
            (from_user_id, to_user_id, to_user_id, from_user_id),
        ).fetchone()
        if pending is not None:
            return False, "A pending request already exists."
        conn.execute(
            "INSERT INTO friend_requests (from_user_id, to_user_id, status) VALUES (?, ?, 'pending')",
            (from_user_id, to_user_id),
        )
        conn.commit()
    return True, "Request sent."


def add_friendship(db_path: str, *, user_a: int, user_b: int) -> tuple[bool, str]:
    if user_a == user_b:
        return False, "You cannot friend yourself."
    if are_friends(db_path, user_a=user_a, user_b=user_b):
        return False, "Already friends."
    with _connect(db_path) as conn:
        conn.execute(
            "INSERT OR IGNORE INTO friendships (user_id, friend_user_id) VALUES (?, ?)",
            (user_a, user_b),
        )
        conn.execute(
            "INSERT OR IGNORE INTO friendships (user_id, friend_user_id) VALUES (?, ?)",
            (user_b, user_a),
        )
        conn.execute(
            """
            UPDATE friend_requests
            SET status = 'accepted', responded_at = datetime('now')
            WHERE ((from_user_id = ? AND to_user_id = ?) OR (from_user_id = ? AND to_user_id = ?))
              AND status = 'pending'
            """,
            (user_a, user_b, user_b, user_a),
        )
        conn.commit()
    return True, "Friends added."


def list_incoming_friend_requests(db_path: str, *, user_id: int) -> list[dict[str, Any]]:
    with _connect(db_path) as conn:
        conn.row_factory = sqlite3.Row
        rows = conn.execute(
            """
            SELECT fr.id, fr.created_at, u.id as from_user_id, u.display_name, u.email
            FROM friend_requests fr
            JOIN users u ON u.id = fr.from_user_id
            WHERE fr.to_user_id = ? AND fr.status = 'pending'
            ORDER BY fr.id DESC
            """,
            (user_id,),
        ).fetchall()
    return [
        {
            "request_id": r["id"],
            "created_at": r["created_at"],
            "from_user_id": r["from_user_id"],
            "display_name": r["display_name"],
            "email": r["email"],
        }
        for r in rows
    ]


def respond_friend_request(db_path: str, *, user_id: int, request_id: int, accept: bool) -> tuple[bool, str]:
    with _connect(db_path) as conn:
        conn.row_factory = sqlite3.Row
        req = conn.execute(
            "SELECT id, from_user_id, to_user_id, status FROM friend_requests WHERE id = ?",
            (request_id,),
        ).fetchone()
        if req is None or req["to_user_id"] != user_id:
            return False, "Request not found."
        if req["status"] != "pending":
            return False, "Request already handled."

        if accept:
            conn.execute(
                "UPDATE friend_requests SET status = 'accepted', responded_at = datetime('now') WHERE id = ?",
                (request_id,),
            )
            conn.execute(
                "INSERT OR IGNORE INTO friendships (user_id, friend_user_id) VALUES (?, ?)",
                (req["from_user_id"], req["to_user_id"]),
            )
            conn.execute(
                "INSERT OR IGNORE INTO friendships (user_id, friend_user_id) VALUES (?, ?)",
                (req["to_user_id"], req["from_user_id"]),
            )
            conn.commit()
            return True, "Friend request accepted."

        conn.execute(
            "UPDATE friend_requests SET status = 'rejected', responded_at = datetime('now') WHERE id = ?",
            (request_id,),
        )
        conn.commit()
        return True, "Friend request rejected."


def list_friend_feed(db_path: str, *, user_id: int) -> list[dict[str, Any]]:
    with _connect(db_path) as conn:
        conn.row_factory = sqlite3.Row
        rows = conn.execute(
            """
            SELECT u.id, u.display_name, u.email, p.bac_now, p.drink_count, p.updated_at
            FROM friendships f
            JOIN users u ON u.id = f.friend_user_id
            LEFT JOIN user_social_settings s ON s.user_id = u.id
            LEFT JOIN user_presence p ON p.user_id = u.id
            WHERE f.user_id = ?
              AND COALESCE(s.share_with_friends, 0) = 1
            ORDER BY p.updated_at DESC, u.display_name COLLATE NOCASE ASC
            """,
            (user_id,),
        ).fetchall()
    out = []
    for r in rows:
        out.append(
            {
                "user_id": r["id"],
                "display_name": r["display_name"],
                "email": r["email"],
                "bac_now": float(r["bac_now"]) if r["bac_now"] is not None else None,
                "drink_count": int(r["drink_count"]) if r["drink_count"] is not None else None,
                "updated_at": r["updated_at"],
            }
        )
    return out


def create_group(db_path: str, *, owner_user_id: int, name: str) -> dict[str, Any]:
    invite_code = secrets.token_urlsafe(6)[:8].upper()
    with _connect(db_path) as conn:
        cur = conn.execute(
            "INSERT INTO social_groups (name, invite_code, owner_user_id) VALUES (?, ?, ?)",
            (name.strip(), invite_code, owner_user_id),
        )
        group_id = int(cur.lastrowid)
        conn.execute(
            "INSERT INTO group_members (group_id, user_id, role, share_enabled) VALUES (?, ?, 'owner', 0)",
            (group_id, owner_user_id),
        )
        conn.commit()
    return {"id": group_id, "name": name.strip(), "invite_code": invite_code}


def list_user_groups(db_path: str, *, user_id: int) -> list[dict[str, Any]]:
    with _connect(db_path) as conn:
        conn.row_factory = sqlite3.Row
        rows = conn.execute(
            """
            SELECT g.id, g.name, g.invite_code, gm.role, gm.share_enabled
            FROM group_members gm
            JOIN social_groups g ON g.id = gm.group_id
            WHERE gm.user_id = ?
            ORDER BY g.id DESC
            """,
            (user_id,),
        ).fetchall()
    return [
        {
            "id": r["id"],
            "name": r["name"],
            "invite_code": r["invite_code"],
            "role": r["role"],
            "share_enabled": bool(r["share_enabled"]),
        }
        for r in rows
    ]


def join_group_by_code(db_path: str, *, user_id: int, invite_code: str) -> tuple[bool, str]:
    with _connect(db_path) as conn:
        conn.row_factory = sqlite3.Row
        grp = conn.execute(
            "SELECT id FROM social_groups WHERE invite_code = ?",
            (invite_code.strip().upper(),),
        ).fetchone()
        if grp is None:
            return False, "Group not found."
        exists = conn.execute(
            "SELECT 1 FROM group_members WHERE group_id = ? AND user_id = ?",
            (grp["id"], user_id),
        ).fetchone()
        if exists is not None:
            return False, "Already in group."
        conn.execute(
            "INSERT INTO group_members (group_id, user_id, role, share_enabled) VALUES (?, ?, 'member', 0)",
            (grp["id"], user_id),
        )
        conn.commit()
    return True, "Joined group."


def is_group_member(db_path: str, *, group_id: int, user_id: int) -> bool:
    with _connect(db_path) as conn:
        row = conn.execute(
            "SELECT 1 FROM group_members WHERE group_id = ? AND user_id = ?",
            (group_id, user_id),
        ).fetchone()
    return row is not None


def set_group_share_enabled(db_path: str, *, group_id: int, user_id: int, enabled: bool) -> None:
    with _connect(db_path) as conn:
        conn.execute(
            "UPDATE group_members SET share_enabled = ? WHERE group_id = ? AND user_id = ?",
            (1 if enabled else 0, group_id, user_id),
        )
        conn.commit()


def get_group_role(db_path: str, *, group_id: int, user_id: int) -> str | None:
    with _connect(db_path) as conn:
        row = conn.execute(
            "SELECT role FROM group_members WHERE group_id = ? AND user_id = ?",
            (group_id, user_id),
        ).fetchone()
    return row[0] if row else None


def set_group_member_role(db_path: str, *, group_id: int, target_user_id: int, role: str) -> None:
    with _connect(db_path) as conn:
        conn.execute(
            "UPDATE group_members SET role = ? WHERE group_id = ? AND user_id = ?",
            (role, group_id, target_user_id),
        )
        conn.commit()


def set_group_buddy_pair(db_path: str, *, group_id: int, user_a: int, user_b: int) -> None:
    if user_a == user_b:
        raise ValueError("Buddy pair requires two different users")
    with _connect(db_path) as conn:
        conn.execute("DELETE FROM group_buddy_pairs WHERE group_id = ? AND user_id IN (?, ?)", (group_id, user_a, user_b))
        conn.execute(
            """
            INSERT INTO group_buddy_pairs (group_id, user_id, buddy_user_id)
            VALUES (?, ?, ?)
            """,
            (group_id, user_a, user_b),
        )
        conn.execute(
            """
            INSERT INTO group_buddy_pairs (group_id, user_id, buddy_user_id)
            VALUES (?, ?, ?)
            """,
            (group_id, user_b, user_a),
        )
        conn.commit()


def clear_group_buddy_pair(db_path: str, *, group_id: int, user_id: int) -> None:
    with _connect(db_path) as conn:
        conn.row_factory = sqlite3.Row
        row = conn.execute(
            "SELECT buddy_user_id FROM group_buddy_pairs WHERE group_id = ? AND user_id = ?",
            (group_id, user_id),
        ).fetchone()
        buddy_id = int(row["buddy_user_id"]) if row else None
        conn.execute("DELETE FROM group_buddy_pairs WHERE group_id = ? AND user_id = ?", (group_id, user_id))
        if buddy_id is not None:
            conn.execute("DELETE FROM group_buddy_pairs WHERE group_id = ? AND user_id = ?", (group_id, buddy_id))
        conn.commit()


def create_group_alert(
    db_path: str,
    *,
    group_id: int,
    alert_type: str,
    message: str,
    from_user_id: int | None = None,
    target_user_id: int | None = None,
) -> None:
    with _connect(db_path) as conn:
        conn.execute(
            """
            INSERT INTO group_alerts (group_id, from_user_id, target_user_id, alert_type, message)
            VALUES (?, ?, ?, ?, ?)
            """,
            (group_id, from_user_id, target_user_id, alert_type, message),
        )
        conn.commit()


def maybe_create_threshold_alert(db_path: str, *, user_id: int, bac_now: float) -> None:
    if bac_now < 0.08:
        return
    with _connect(db_path) as conn:
        conn.row_factory = sqlite3.Row
        groups = conn.execute(
            "SELECT group_id FROM group_members WHERE user_id = ?",
            (user_id,),
        ).fetchall()
        for g in groups:
            recent = conn.execute(
                """
                SELECT 1 FROM group_alerts
                WHERE group_id = ? AND from_user_id = ? AND alert_type = 'threshold'
                  AND created_at >= datetime('now', '-30 minutes')
                """,
                (g["group_id"], user_id),
            ).fetchone()
            if recent is None:
                conn.execute(
                    """
                    INSERT INTO group_alerts (group_id, from_user_id, alert_type, message)
                    VALUES (?, ?, 'threshold', ?)
                    """,
                    (g["group_id"], user_id, "High BAC alert: friend may need water/ride support."),
                )
        conn.commit()


def get_group_snapshot(db_path: str, *, group_id: int, user_id: int) -> dict[str, Any] | None:
    if not is_group_member(db_path, group_id=group_id, user_id=user_id):
        return None
    with _connect(db_path) as conn:
        conn.row_factory = sqlite3.Row
        group = conn.execute(
            "SELECT id, name, invite_code FROM social_groups WHERE id = ?",
            (group_id,),
        ).fetchone()
        if group is None:
            return None
        members = conn.execute(
            """
            SELECT u.id, u.display_name, u.email, gm.role, gm.share_enabled,
                   p.bac_now, p.drink_count, p.location_note, p.updated_at
            FROM group_members gm
            JOIN users u ON u.id = gm.user_id
            LEFT JOIN user_presence p ON p.user_id = gm.user_id
            WHERE gm.group_id = ?
            ORDER BY gm.role DESC, u.display_name COLLATE NOCASE ASC
            """,
            (group_id,),
        ).fetchall()
        alerts = conn.execute(
            """
            SELECT id, alert_type, message, created_at, from_user_id, target_user_id
            FROM group_alerts
            WHERE group_id = ?
            ORDER BY id DESC
            LIMIT 40
            """,
            (group_id,),
        ).fetchall()
        buddies = conn.execute(
            """
            SELECT user_id, buddy_user_id
            FROM group_buddy_pairs
            WHERE group_id = ?
            """,
            (group_id,),
        ).fetchall()

    member_out = []
    buddy_map = {int(b["user_id"]): int(b["buddy_user_id"]) for b in buddies}
    for m in members:
        share_enabled = bool(m["share_enabled"])
        can_view = share_enabled or m["id"] == user_id
        member_out.append(
            {
                "user_id": m["id"],
                "display_name": m["display_name"],
                "email": m["email"],
                "role": m["role"],
                "share_enabled": share_enabled,
                "bac_now": float(m["bac_now"]) if can_view and m["bac_now"] is not None else None,
                "drink_count": int(m["drink_count"]) if can_view and m["drink_count"] is not None else None,
                "location_note": m["location_note"] if can_view else None,
                "updated_at": m["updated_at"] if can_view else None,
                "buddy_user_id": buddy_map.get(int(m["id"])),
            }
        )

    alert_out = [
        {
            "id": a["id"],
            "alert_type": a["alert_type"],
            "message": a["message"],
            "created_at": a["created_at"],
            "from_user_id": a["from_user_id"],
            "target_user_id": a["target_user_id"],
        }
        for a in alerts
    ]
    return {
        "group": {"id": group["id"], "name": group["name"], "invite_code": group["invite_code"]},
        "members": member_out,
        "alerts": alert_out,
    }


def create_guardian_link(
    db_path: str,
    *,
    group_id: int,
    label: str,
    receive_alerts: bool = True,
) -> dict[str, Any]:
    token = secrets.token_urlsafe(24)
    with _connect(db_path) as conn:
        cur = conn.execute(
            """
            INSERT INTO guardian_links (group_id, label, token, receive_alerts, is_active)
            VALUES (?, ?, ?, ?, 1)
            """,
            (group_id, label.strip(), token, 1 if receive_alerts else 0),
        )
        conn.commit()
        link_id = int(cur.lastrowid)
    return {
        "id": link_id,
        "group_id": group_id,
        "label": label.strip(),
        "token": token,
        "receive_alerts": bool(receive_alerts),
        "is_active": True,
    }


def list_guardian_links(db_path: str, *, group_id: int) -> list[dict[str, Any]]:
    with _connect(db_path) as conn:
        conn.row_factory = sqlite3.Row
        rows = conn.execute(
            """
            SELECT id, label, token, receive_alerts, is_active, created_at
            FROM guardian_links
            WHERE group_id = ?
            ORDER BY id DESC
            """,
            (group_id,),
        ).fetchall()
    return [
        {
            "id": r["id"],
            "label": r["label"],
            "token": r["token"],
            "receive_alerts": bool(r["receive_alerts"]),
            "is_active": bool(r["is_active"]),
            "created_at": r["created_at"],
        }
        for r in rows
    ]


def revoke_guardian_link(db_path: str, *, group_id: int, link_id: int) -> bool:
    with _connect(db_path) as conn:
        cur = conn.execute(
            "UPDATE guardian_links SET is_active = 0 WHERE id = ? AND group_id = ?",
            (link_id, group_id),
        )
        conn.commit()
        return cur.rowcount > 0


def set_guardian_link_alerts(db_path: str, *, group_id: int, link_id: int, enabled: bool) -> bool:
    with _connect(db_path) as conn:
        cur = conn.execute(
            "UPDATE guardian_links SET receive_alerts = ? WHERE id = ? AND group_id = ?",
            (1 if enabled else 0, link_id, group_id),
        )
        conn.commit()
        return cur.rowcount > 0


def get_group_snapshot_by_guardian_token(db_path: str, *, token: str) -> dict[str, Any] | None:
    with _connect(db_path) as conn:
        conn.row_factory = sqlite3.Row
        link = conn.execute(
            """
            SELECT gl.id, gl.group_id, gl.label, gl.receive_alerts, gl.is_active,
                   g.name, g.invite_code
            FROM guardian_links gl
            JOIN social_groups g ON g.id = gl.group_id
            WHERE gl.token = ?
            """,
            (token,),
        ).fetchone()
        if link is None or not bool(link["is_active"]):
            return None

        members = conn.execute(
            """
            SELECT u.display_name, gm.role, p.bac_now, p.drink_count, p.location_note, p.updated_at
            FROM group_members gm
            JOIN users u ON u.id = gm.user_id
            LEFT JOIN user_presence p ON p.user_id = gm.user_id
            WHERE gm.group_id = ? AND gm.share_enabled = 1
            ORDER BY gm.role DESC, u.display_name COLLATE NOCASE ASC
            """,
            (link["group_id"],),
        ).fetchall()

        alerts = conn.execute(
            """
            SELECT id, alert_type, message, created_at
            FROM group_alerts
            WHERE group_id = ?
            ORDER BY id DESC
            LIMIT 40
            """,
            (link["group_id"],),
        ).fetchall()

    return {
        "guardian_link": {
            "id": link["id"],
            "label": link["label"],
            "receive_alerts": bool(link["receive_alerts"]),
        },
        "group": {"id": link["group_id"], "name": link["name"], "invite_code": link["invite_code"]},
        "members": [
            {
                "display_name": m["display_name"],
                "role": m["role"],
                "bac_now": float(m["bac_now"]) if m["bac_now"] is not None else None,
                "drink_count": int(m["drink_count"]) if m["drink_count"] is not None else None,
                "location_note": m["location_note"],
                "updated_at": m["updated_at"],
            }
            for m in members
        ],
        "alerts": [
            {"id": a["id"], "alert_type": a["alert_type"], "message": a["message"], "created_at": a["created_at"]}
            for a in alerts
        ],
    }


def revoke_all_sharing_for_user(db_path: str, *, user_id: int) -> None:
    with _connect(db_path) as conn:
        conn.execute(
            "UPDATE user_social_settings SET share_with_friends = 0, updated_at = datetime('now') WHERE user_id = ?",
            (user_id,),
        )
        conn.execute(
            "UPDATE group_members SET share_enabled = 0 WHERE user_id = ?",
            (user_id,),
        )
        # Revoke guardian links in groups user owns or moderates.
        conn.execute(
            """
            UPDATE guardian_links
            SET is_active = 0
            WHERE group_id IN (
              SELECT group_id FROM group_members
              WHERE user_id = ? AND role IN ('owner', 'mod')
            )
            """,
            (user_id,),
        )
        conn.commit()


def get_privacy_summary(db_path: str, *, user_id: int) -> dict[str, Any]:
    with _connect(db_path) as conn:
        share_row = conn.execute(
            "SELECT COALESCE(share_with_friends, 0) FROM user_social_settings WHERE user_id = ?",
            (user_id,),
        ).fetchone()
        group_row = conn.execute(
            "SELECT COUNT(*) FROM group_members WHERE user_id = ? AND share_enabled = 1",
            (user_id,),
        ).fetchone()
        guardian_row = conn.execute(
            """
            SELECT COUNT(*)
            FROM guardian_links gl
            WHERE gl.is_active = 1
              AND gl.group_id IN (
                SELECT gm.group_id FROM group_members gm
                WHERE gm.user_id = ? AND gm.role IN ('owner', 'mod')
              )
            """,
            (user_id,),
        ).fetchone()
    return {
        "share_with_friends": bool(share_row[0]) if share_row else False,
        "group_shares_enabled": int(group_row[0]) if group_row else 0,
        "active_guardian_links": int(guardian_row[0]) if guardian_row else 0,
    }


def list_emergency_contacts(db_path: str, *, user_id: int) -> list[dict[str, Any]]:
    with _connect(db_path) as conn:
        conn.row_factory = sqlite3.Row
        rows = conn.execute(
            """
            SELECT id, name, phone, created_at
            FROM emergency_contacts
            WHERE user_id = ?
            ORDER BY id DESC
            """,
            (user_id,),
        ).fetchall()
    return [{"id": r["id"], "name": r["name"], "phone": r["phone"], "created_at": r["created_at"]} for r in rows]


def add_emergency_contact(db_path: str, *, user_id: int, name: str, phone: str) -> dict[str, Any]:
    with _connect(db_path) as conn:
        cur = conn.execute(
            "INSERT INTO emergency_contacts (user_id, name, phone) VALUES (?, ?, ?)",
            (user_id, name.strip(), phone.strip()),
        )
        conn.commit()
        contact_id = int(cur.lastrowid)
    return {"id": contact_id, "name": name.strip(), "phone": phone.strip()}


def delete_emergency_contact(db_path: str, *, user_id: int, contact_id: int) -> bool:
    with _connect(db_path) as conn:
        cur = conn.execute(
            "DELETE FROM emergency_contacts WHERE id = ? AND user_id = ?",
            (contact_id, user_id),
        )
        conn.commit()
        return cur.rowcount > 0


def create_password_reset_token(db_path: str, *, email: str, ttl_minutes: int = 30) -> str | None:
    expires_at = (datetime.now(timezone.utc) + timedelta(minutes=max(1, ttl_minutes))).strftime("%Y-%m-%d %H:%M:%S")
    with _connect(db_path) as conn:
        conn.row_factory = sqlite3.Row
        user = conn.execute("SELECT id FROM users WHERE lower(email) = ?", (email.strip().lower(),)).fetchone()
        if user is None:
            return None
        token = secrets.token_urlsafe(24)
        conn.execute(
            """
            INSERT INTO password_resets (user_id, token, expires_at)
            VALUES (?, ?, ?)
            """,
            (int(user["id"]), token, expires_at),
        )
        conn.commit()
        return token


def consume_password_reset_token(db_path: str, *, token: str, new_password: str) -> bool:
    password_hash = generate_password_hash(new_password)
    with _connect(db_path) as conn:
        conn.row_factory = sqlite3.Row
        row = conn.execute(
            """
            SELECT id, user_id
            FROM password_resets
            WHERE token = ? AND used_at IS NULL AND expires_at > datetime('now')
            """,
            (token.strip(),),
        ).fetchone()
        if row is None:
            return False
        conn.execute("UPDATE users SET password_hash = ? WHERE id = ?", (password_hash, int(row["user_id"])))
        conn.execute("UPDATE password_resets SET used_at = datetime('now') WHERE id = ?", (int(row["id"]),))
        conn.commit()
        return True


def create_email_verification_token(db_path: str, *, user_id: int, ttl_minutes: int = 60 * 24) -> str:
    token = secrets.token_urlsafe(24)
    expires_at = (datetime.now(timezone.utc) + timedelta(minutes=max(1, ttl_minutes))).strftime("%Y-%m-%d %H:%M:%S")
    with _connect(db_path) as conn:
        conn.execute(
            """
            INSERT INTO email_verifications (user_id, token, expires_at)
            VALUES (?, ?, ?)
            """,
            (user_id, token, expires_at),
        )
        conn.commit()
    return token


def verify_email_token(db_path: str, *, token: str) -> bool:
    with _connect(db_path) as conn:
        conn.row_factory = sqlite3.Row
        row = conn.execute(
            """
            SELECT id, user_id
            FROM email_verifications
            WHERE token = ? AND used_at IS NULL AND expires_at > datetime('now')
            """,
            (token.strip(),),
        ).fetchone()
        if row is None:
            return False
        conn.execute("UPDATE users SET email_verified = 1 WHERE id = ?", (int(row["user_id"]),))
        conn.execute("UPDATE email_verifications SET used_at = datetime('now') WHERE id = ?", (int(row["id"]),))
        conn.commit()
        return True
